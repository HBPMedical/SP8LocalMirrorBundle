#RAW Query Engine
##Description
The Local data store query engine is a database system specially tailored for the needs of the HBP. Its main purpose is to offer efficient querying services directly on files inside the hospital. The type of research involved, biological signatures of diseases, requires more advanced data structures and more expressive operations than those provided by traditional databases. 
The query language enables users to apply powerful transformations over the output of a query. RAW uses a query language, similar to SQL (Structured Query Language) that provides support for a multitude of data models: collection types, hierarchies and multi-dimensional arrays. This flexibility enables queries to transparently access a great variety of datasets (e.g., relational tables, CSV and JSON files, array image data, etc.).
Furthermore to be able to query from heterogeneous data formats, RAW utilizes code generation techniques. When a query is posed code generation plug-ins are invoked to produce code specific to both the file format and the query posed. Code generation acts as an enabler for queries targeting multiple data formats. In addition, it improves performance, as each query leads to execution of very specific code, avoiding generic methods that would take place (e.g., parsing the data files using a generic parser).
RAW currently supports the following functionality:
Get list of the available schemas/ registered files patients, exams values, brain features.
Submit queries and retrieve results.
Submit paginated queries (streaming).
Register new files to be queried. 

##Technologies
The query engine system requirements are:
   * Operating system: Linux 
   * RAM: 8GB or higher
   * Java version: 8.0 or higher
   * Scala version: 2.11 or higher

##Usage
The Query Engine exposes a declarative query interface that is used to provide access to the resources residing in the Data Store Mirror. While all incoming requests are expressed using the declarative language offered, the nature of the requests differs slightly based on the type of user currently interacting with the Medical Informatics Platform. We will now examine the types of interaction that we have identified.

**Epidemiological Exploration**

In this use case, users are mainly interested in exploring the clinical data offered by each hospital. The aim of their interaction with the platform will be the acquisition of high-level global information on the available data. This interaction will be facilitated by the use of an interactive query builder through which the users will formulate their queries. Naturally, the queries expressed using a query builder have to follow some specific templates. These templates will adhere to the terms present in the ontologies defined for the description of the underlying datasets. Therefore, their layout will be straightforward. The only significant difference between the queries posed will be the selectivity of the filtering predicates involved. 

**Extraction of disease signatures**

When the Query Engine is used to facilitate extraction of biological disease signatures and general data mining tasks, the queries do not necessarily follow some pre-defined template, nor take the developed ontologies into account. Instead, a data mining process can involve a sequence of arbitrary queries, or modified iterations of the same query, comprising a workflow. The users in this scenario must "push" as much of the data mining computation as possible to the Query Engine instances in the local hospitals for two reasons:
First, distributing the computation successfully will remove load from the federated infrastructure, and avoid causing a bottleneck at any node. Most importantly, privacy concerns do not allow the data required for the data mining tasks to be copied outside each hospital's infrastructure, thus making distributed, local computation a necessity.

**Input** 

RAW uses as input the files generated by MIPMap. It supports the following data formats:
   * CSV
   * JSON
   * XML
   * Text and log files

**Output**
 
A REST service with the query results in JSON format. The specification of the REST interface can be found in the appendix in section Error: Reference source not found.
